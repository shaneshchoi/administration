package com.example.administration

import android.content.Context
import androidx.lifecycle.LiveData
import androidx.room.Dao
import androidx.room.Database
import androidx.room.Entity
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.PrimaryKey
import androidx.room.Query
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.Transaction

// Defining EmployeeEntity
// PrimaryKey is the integer id, autogenerated
// others include name, address, email, and team
@Entity(tableName = "Employee_table")
data class EmployeeEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Int = 0,
    val name: String,
    val address: String,
    val email: String,
    val team: String,
)

// DAO for interacting with the database
@Dao
interface EmployeeDao {
    //Retrieve all Employees
    @Query("SELECT * FROM Employee_table")
    fun getAllEmployee(): LiveData<List<EmployeeEntity>>
    //Insert employeelist
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertEmployeeList(employeeList: List<EmployeeEntity>)
    //delete employe by id
    @Query("DELETE FROM Employee_table WHERE Id = :Id")
    fun deleteEmployeeById(Id: Int)
    //order employee by id
    @Query("SELECT * FROM Employee_table ORDER BY Id")
    fun getAllEmployeesOrderedById(): List<EmployeeEntity>
    //delete all the employees
    @Query("DELETE FROM Employee_table")
    fun deleteAll()
    //check if given id value exists in the table
    @Query("SELECT COUNT(*) FROM Employee_table WHERE Id = :Id")
    fun checkIdExist(Id: Int): Int
    //Reorder the database so that early-created primaryKeys be updated to 1, 2, 3.. etc whenever
    //they are being deleted.
    @Transaction
    fun reorderIds() {
        val remainingEmployees = getAllEmployeesOrderedById()
        deleteAll()
        val updatedEmployees = remainingEmployees.mapIndexed { index, employee ->
            employee.copy(id = index+1)
        }
        insertEmployeeList(updatedEmployees)
    }
    //Get the maximum integer value in the table
    @Query("SELECT MAX(id) FROM Employee_table")
    fun getMaxEmployeeId(): Int
    //Enables to set the next coming primary keys based on the maximum primary key
    //value in the database.
    @Transaction
    fun insertEmployee(employee: EmployeeEntity) {
        val currentMaxId = getMaxEmployeeId()
        val nextId = currentMaxId + 1

        val newEmployee = employee.copy(id = nextId)
        insertEmployeeList(listOf(newEmployee))
    }
}

// Setting up the ROOM DB
@Database(entities = [EmployeeEntity::class], version = 1)
abstract class EmployeeDatabase : RoomDatabase() {
    abstract fun empDao(): EmployeeDao

    companion object {
        @Volatile
        private var INSTANCE: EmployeeDatabase? = null
        // Build following database instances and setting the instance that was created
        // to match the created instance and then return it.
        fun getDatabase(context: Context): EmployeeDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    EmployeeDatabase::class.java,
                    "employee_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}